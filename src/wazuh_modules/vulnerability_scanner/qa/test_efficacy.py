import json
import platform
import subprocess
import socket
import os
import time
from pathlib import Path

import pytest
from jsonschema import validate
from jsonschema.exceptions import ValidationError

import logging

LOGGER = logging.getLogger(__name__)

def sendflatbuffer_to_unixsocket(data):
    # Create a unix socket
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    # Connect to the socket
    try:
        sock.connect("queue/router/deltas-syscollector")
        size = len(data)+5;
        data_to_send = size.to_bytes(4, byteorder="little")
        header_size = 1
        data_to_send += header_size.to_bytes(4, byteorder="little")
        data_to_send += b"P"
        data_to_send += data

        # Send the data
        sock.send(data_to_send)

    except Exception as e:
        LOGGER.info(e)
        return None


def json2binary(test, output):
    command = ["external/flatbuffers/build/flatc", "--binary", "-o", output, "shared_modules/utils/flatbuffers/schemas/syscollectorDeltas/syscollector_deltas.fbs", test]
    # Execute the flatbuffer compiler
    result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)


def test_false_negatives():
    # change working directory to the root of the project parent directory
    # This is required to run the binary
    os.chdir(Path(__file__).parent.parent.parent.parent)

    # Delete previous inventory directory if exists
    if Path("queue/vd/inventory").exists():
        for file in Path("queue/vd/inventory").glob("*"):
            file.unlink()
        Path("queue/vd/inventory").rmdir()

    # Set the path to the binary
    cmd = Path("build/wazuh_modules/vulnerability_scanner/testtool/scanner/", "vd_scanner_testtool")
    cmdAlt = Path("wazuh_modules/vulnerability_scanner/build/testtool/scanner/", "vd_scanner_testtool")

    # Ensure the binary exists
    if not cmd.exists():
        cmd = cmdAlt
    assert cmd.exists(), "The binary does not exists"

    args = ["-c", "wazuh_modules/vulnerability_scanner/testtool/scanner/config.json",
            "-t", "wazuh_modules/vulnerability_scanner/indexer/template/legacy-template.json"]

    command = [cmd] + args

    # Iterate over folders in the test directory
    test_folders = sorted(Path("wazuh_modules/vulnerability_scanner/qa/test_data").glob("*"))

    for test_folder in test_folders:
        LOGGER.info(f"Running test {test_folder}")
        # Iterate over json files in the test directory, convert to flatbuffer and send through unix socket
        process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
        while True:
            output = process.stdout.readline()
            if output == '' and process.poll() is not None:
                break
            if output:
                if "Press enter to stop the scanner..." in output:
                    LOGGER.info("Process started")
                    break

        # Sort the json files, to process tests in order.
        json_files = sorted(Path(test_folder).glob("input_*.json"))

        for json_file in json_files:
            LOGGER.info(f"Running test {json_file}")
            with open(json_file) as f:
                # Set the output file
                file = str(json_file)

                # Set the output folder
                output_folder = str(test_folder)

                # Set the output file
                output = str(json_file).replace(".json", ".bin")

                # Convert the json data to flatbuffer
                json2binary(file, output_folder)

                # Read the flatbuffer data
                with open(output, "rb") as f:
                    flatbuffer_data = f.read()

                expected_file = json_file.name.replace("input_", "expected_")
                expected_file = expected_file.replace(".json", ".out")
                expected_output = None
                # Read expected output if it exists, this is an json with and array of lines.
                if Path(test_folder, expected_file).exists():
                    # JSON parsed to a Python dict
                    expected_output = json.loads(Path(test_folder, expected_file).read_text())
                    LOGGER.info(f"Expected output: {expected_output}")

                # After start to read lines, send the flatbuffer data
                first_read = False

                # Set the expected elements size
                if (expected_output is not None):
                    expected_elements = len(expected_output)
                else:
                    expected_elements = 0

                # Init current elements match
                current_elements = 0

                # If after 10 seconds the process is not finished, the test is failed
                start_time = time.time()
                while True:
                    if time.time() - start_time > 10:
                        assert False, "The test is failed because the process is not finished after 10 seconds"
                        break
                    output = process.stdout.readline()
                    if output == '' and process.poll() is not None:
                        break
                    if output:
                        # Send the flatbuffer data, when the process is started and the stdout is read
                        if first_read is False:
                            sendflatbuffer_to_unixsocket(flatbuffer_data)
                            first_read = True

                        # If there is an expected output, try to match the output with the expected output
                        if expected_output:
                            # Try to match the output with the expected output
                            for line in expected_output:
                                # Check if the line contains the expected output
                                if line in output.strip():
                                    current_elements += 1
                                    break
                            if current_elements == expected_elements:
                                LOGGER.info("Test OK")
                                break
                        # If there is no expected output, the test is passed
                        else:
                            break
                assert current_elements == expected_elements, "The test is failed because the expected output is not found"
                LOGGER.info("Test finished")
        process.kill()
